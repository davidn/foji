// Code generated by foji 0.4, template: foji/sqlRepo.go.tpl; DO NOT EDIT.

package pg

import (
	"context"
	"fmt"
)

// Table represents a result from 'GetTables'.
type Table struct {
	ID        uint32 `json:"id,omitempty"`         // postgres type: oid
	Schema    string `json:"schema,omitempty"`     // postgres type: name
	Name      string `json:"name,omitempty"`       // postgres type: name
	Type      string `json:"type,omitempty"`       // postgres type: text
	CanUpdate bool   `json:"can_update,omitempty"` // postgres type: bool
	CanInsert bool   `json:"can_insert,omitempty"` // postgres type: bool
	CanDelete bool   `json:"can_delete,omitempty"` // postgres type: bool
	Comment   string `json:"comment,omitempty"`    // postgres type: text
}

// GetTables returns Table
func (r Repo) GetTables(ctx context.Context) ([]*Table, error) {
	const query = `--# GetTables Table
SELECT c.oid                                                                                                         AS id,
       n.nspname                                                                                                     AS schema,
       c.relname                                                                                                     AS name,
       CASE c.relkind WHEN 'r' THEN 'table'
                      WHEN 'f' THEN 'foreign'
                      WHEN 'v' THEN 'view'
                      WHEN 's'
                          THEN 'special' END                                                                         AS type,
       (pg_relation_is_updatable(c.oid::regclass, FALSE) & 4) = 4                                                    AS can_update,
       (pg_relation_is_updatable(c.oid::regclass, FALSE) & 8) = 8                                                    AS can_insert,
       (pg_relation_is_updatable(c.oid::regclass, FALSE) & 16) = 16                                                  AS can_delete,
       COALESCE(obj_description(c.oid), '')                                                                          AS comment
FROM pg_class c
         LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE c.relkind IN ('r', 'p', 'v', 'f')
  AND n.nspname <> 'pg_catalog'
  AND n.nspname <> 'information_schema'
  AND n.nspname !~ '^pg_toast'
  AND n.nspname !~ '^pg_temp_'
ORDER BY schema, name`
	q, err := r.db.Query(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("GetTables.Query:%w", err)
	}

	var out []*Table

	for q.Next() {
		row := Table{}
		err := q.Scan(&row.ID, &row.Schema, &row.Name, &row.Type, &row.CanUpdate, &row.CanInsert, &row.CanDelete, &row.Comment)
		if err != nil {
			return nil, fmt.Errorf("GetTables.Scan:%w", err)
		}

		out = append(out, &row)
	}

	return out, nil
}

// Index represents a result from 'GetIndexes'.
type Index struct {
	ID        uint32   `json:"id,omitempty"`         // postgres type: oid
	Schema    string   `json:"schema,omitempty"`     // postgres type: name
	Name      string   `json:"name,omitempty"`       // postgres type: name
	Table     string   `json:"table,omitempty"`      // postgres type: name
	IsUnique  bool     `json:"is_unique,omitempty"`  // postgres type: bool
	IsPrimary bool     `json:"is_primary,omitempty"` // postgres type: bool
	Columns   []string `json:"columns,omitempty"`    // postgres type: _name
	Comment   string   `json:"comment,omitempty"`    // postgres type: text
}

// GetIndexes returns Index
func (r Repo) GetIndexes(ctx context.Context) ([]*Index, error) {
	const query = `--# GetIndexes Index
SELECT ix.indexrelid                                                                              AS id,
       n.nspname                                                                                  AS schema,
       c.relname                                                                                  AS name,
       t.relname                                                                                  AS table,
       ix.indisunique                                                                             AS is_unique,
       ix.indisprimary                                                                            AS is_primary,
       Array(SELECT attname FROM pg_attribute a WHERE a.attrelid = ix.indexrelid ORDER BY attnum) AS columns,
       COALESCE(obj_description(ix.indexrelid), '')                                               AS comment
FROM pg_index ix
         JOIN pg_class t ON t.oid = ix.indrelid
         JOIN pg_class c ON c.oid = ix.indexrelid
         JOIN pg_namespace AS n ON n.oid = c.relnamespace
WHERE n.nspname NOT IN ('pg_toast', 'pg_temp_1', 'pg_toast_temp_1', 'pg_catalog', 'information_schema')
ORDER BY t.relname, c.relname`
	q, err := r.db.Query(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("GetIndexes.Query:%w", err)
	}

	var out []*Index

	for q.Next() {
		row := Index{}
		err := q.Scan(&row.ID, &row.Schema, &row.Name, &row.Table, &row.IsUnique, &row.IsPrimary, &row.Columns, &row.Comment)
		if err != nil {
			return nil, fmt.Errorf("GetIndexes.Scan:%w", err)
		}

		out = append(out, &row)
	}

	return out, nil
}

// Enum represents a result from 'GetEnums'.
type Enum struct {
	ID      uint32   `json:"id,omitempty"`      // postgres type: oid
	Name    string   `json:"name,omitempty"`    // postgres type: name
	Schema  string   `json:"schema,omitempty"`  // postgres type: name
	Values  []string `json:"values,omitempty"`  // postgres type: _name
	Comment string   `json:"comment,omitempty"` // postgres type: text
}

// GetEnums returns Enum
func (r Repo) GetEnums(ctx context.Context) ([]*Enum, error) {
	const query = `--# GetEnums Enum
SELECT t.oid                                                                               AS id,
       t.typname                                                                           AS name,
       n.nspname                                                                           AS schema,
       Array(SELECT enumlabel FROM pg_enum WHERE enumtypid = t.oid ORDER BY enumsortorder) AS values,
       COALESCE(obj_description(t.oid), '')                                                AS comment
FROM pg_type t
         JOIN pg_namespace AS n ON n.oid = t.typnamespace
WHERE t.typtype = 'e'`
	q, err := r.db.Query(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("GetEnums.Query:%w", err)
	}

	var out []*Enum

	for q.Next() {
		row := Enum{}
		err := q.Scan(&row.ID, &row.Name, &row.Schema, &row.Values, &row.Comment)
		if err != nil {
			return nil, fmt.Errorf("GetEnums.Scan:%w", err)
		}

		out = append(out, &row)
	}

	return out, nil
}

// ForeignKey represents a result from 'GetForeignKeys'.
type ForeignKey struct {
	ID             uint32   `json:"id,omitempty"`              // postgres type: oid
	Schema         string   `json:"schema,omitempty"`          // postgres type: name
	Name           string   `json:"name,omitempty"`            // postgres type: name
	Table          string   `json:"table,omitempty"`           // postgres type: name
	Columns        []string `json:"columns,omitempty"`         // postgres type: _name
	ForeignSchema  string   `json:"foreign_schema,omitempty"`  // postgres type: name
	ForeignTable   string   `json:"foreign_table,omitempty"`   // postgres type: name
	ForeignColumns []string `json:"foreign_columns,omitempty"` // postgres type: _name
	Comment        string   `json:"comment,omitempty"`         // postgres type: text
}

// GetForeignKeys returns ForeignKey
func (r Repo) GetForeignKeys(ctx context.Context) ([]*ForeignKey, error) {
	const query = `--# GetForeignKeys ForeignKey
SELECT con.oid                                                                             AS id,
       (
           SELECT nspname
           FROM pg_namespace ns
           WHERE cl.relnamespace = ns.oid )                                                AS schema,
       conname                                                                             AS name,
       cl.relname                                                                          AS table,
       ARRAY(SELECT attname
             FROM pg_attribute a
             WHERE a.attrelid = con.conrelid AND a.attnum = ANY (con.conkey)
             ORDER BY attnum)                                                              AS columns,
       (
           SELECT nspname FROM pg_namespace ns WHERE foreign_class.relnamespace = ns.oid ) AS foreign_schema,
       foreign_class.relname                                                               AS foreign_table,
       ARRAY(SELECT attname
             FROM pg_attribute a
             WHERE a.attrelid = con.confrelid AND a.attnum = ANY (con.confkey)
             ORDER BY attnum)                                                              AS foreign_columns,
       COALESCE(obj_description(con.oid), '')                                              AS comment
FROM pg_class cl
         JOIN pg_constraint con ON con.conrelid = cl.oid
         JOIN pg_class foreign_class ON foreign_class.oid = con.confrelid`
	q, err := r.db.Query(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("GetForeignKeys.Query:%w", err)
	}

	var out []*ForeignKey

	for q.Next() {
		row := ForeignKey{}
		err := q.Scan(&row.ID, &row.Schema, &row.Name, &row.Table, &row.Columns, &row.ForeignSchema, &row.ForeignTable, &row.ForeignColumns, &row.Comment)
		if err != nil {
			return nil, fmt.Errorf("GetForeignKeys.Scan:%w", err)
		}

		out = append(out, &row)
	}

	return out, nil
}

// Column represents a result from 'GetColumns'.
type Column struct {
	Schema     string `json:"schema,omitempty"`      // postgres type: name
	Table      string `json:"table,omitempty"`       // postgres type: name
	Name       string `json:"name,omitempty"`        // postgres type: name
	Ordinal    int16  `json:"ordinal,omitempty"`     // postgres type: int2
	Nullable   bool   `json:"nullable,omitempty"`    // postgres type: bool
	HasDefault bool   `json:"has_default,omitempty"` // postgres type: bool
	Type       string `json:"type,omitempty"`        // postgres type: name
	Comment    string `json:"comment,omitempty"`     // postgres type: text
}

// GetColumns returns Column
func (r Repo) GetColumns(ctx context.Context) ([]*Column, error) {
	const query = `--# GetColumns Column
SELECT n.nspname                                           AS schema,
       c.relname                                           AS table,
       a.attname                                           AS name,
       attnum                                              AS ordinal,
       NOT a.attnotnull                                    AS nullable,
       atthasdef                                           AS has_default,
       (
           SELECT typname
           FROM pg_type
           WHERE oid = atttypid )                          AS type,
       COALESCE(col_description(a.attrelid, a.attnum), '') AS comment
FROM pg_attribute a
         JOIN pg_class c ON attrelid = c.oid AND relkind IN ('v', 'r')
         JOIN pg_namespace n
              ON c.relnamespace = n.oid AND nspname NOT IN ('pg_toast', 'pg_temp_1', 'pg_toast_temp_1', 'pg_catalog',
                                                            'information_schema')
WHERE a.attnum > 0 and atttypid > 0
ORDER BY schema, "table", ordinal`
	q, err := r.db.Query(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("GetColumns.Query:%w", err)
	}

	var out []*Column

	for q.Next() {
		row := Column{}
		err := q.Scan(&row.Schema, &row.Table, &row.Name, &row.Ordinal, &row.Nullable, &row.HasDefault, &row.Type, &row.Comment)
		if err != nil {
			return nil, fmt.Errorf("GetColumns.Scan:%w", err)
		}

		out = append(out, &row)
	}

	return out, nil
}
