{{ .NotNeededIf (not .HasAuthentication) "no security schemes" -}}
{{ .ErrorIf (empty $.Params.Auth) "params.Auth" -}}
// Code generated by foji {{ version }}, template: {{ templateFile }}; DO NOT EDIT.
{{ $packageName := "http" }}
package http

import (
	"context"
	"encoding/base64"
	"net/http"
	"strings"

	"github.com/bir/iken/httputil"
{{- .CheckAllTypes "http" $.Params.Auth -}}
{{- range .GoImports }}
	"{{ . }}"
{{- end }}
)

// HttpAuthFunc is the signature of a function used to authenticate an http request.
// Given a request, it returns the authenticated user.  If unable to authenticate the
// request it returns an error.
type HttpAuthFunc = func(r *http.Request) (*{{ $.CheckPackage $.Params.Auth $packageName }}, error)

// Authenticator takes a key (for example a bearer token) and returns the authenticated user.
type Authenticator = func(ctx context.Context, key string) (*{{ $.CheckPackage $.Params.Auth $packageName }}, error)

{{- if .HasBasicAuth }}

// BasicAuthenticator takes a user/pass pair and returns the authenticated user.
type BasicAuthenticator = func(user,pass string) (*{{ $.CheckPackage $.Params.Auth $packageName }}, error)
{{- end}}

{{- if .HasAuthorization }}

// Authorizer is given an authenticated User and a list of scopes to validate.
type Authorizer = func(user *{{ $.CheckPackage $.Params.Auth $packageName }}, scopes ...string ) (error)
{{- end}}

{{- if or .HasBasicAuth .HasBearerAuth }}
var (
{{- if .HasBasicAuth }}
    basicAuthPrefix = "Basic "
{{- end}}
{{- if .HasBearerAuth }}
    bearerAuthPrefix = "Bearer "
{{- end}}
)
{{- end}}

{{- range $security, $value := .File.API.Components.SecuritySchemes }}
// {{toJson $value}}
// {{ pascal $security }}Auth is responsible for extracting "{{$security}}" credentials from a request and calling the
// supplied Authenticator to authenticate
{{ goDoc $value.Value.Description }}
func {{ pascal $security }}Auth(fn {{if eq $value.Value.Scheme "basic"}}Basic{{end}}Authenticator) HttpAuthFunc {
	return func(r *http.Request) (*{{ $.CheckPackage $.Params.Auth $packageName }}, error) {
    {{- if eq $value.Value.Type "apiKey" }}
        {{- if eq $value.Value.In "query" }}
		key := r.URL.Query().Get("{{$value.Value.Name}}")
		if len(key) == 0 {
			return nil, httputil.ErrUnauthorized
		}
        {{- else if eq $value.Value.In "header" }}
		key := r.Header.Get("{{ $value.Value.Name }}")
		if len(key) == 0 {
			return nil, httputil.ErrUnauthorized
		}
        {{- else if eq $value.Value.In "cookie" }}
		cookie := r.Cookie("{{$value.Value.Name}}")
		if cookie == nil || len(cookie.Value) == 0 {
			return nil, httputil.ErrUnauthorized
		}

		key := cookie.Value
        {{end}}

		return fn(r.Context(), key)
    {{- else if eq $value.Value.Type "http" }}
        {{- if eq $value.Value.Scheme "bearer" }}
		key := r.Header.Get("Authorization")
		if len(key) == 0 {
			return nil, httputil.ErrUnauthorized
		}

		if strings.HasPrefix(key, bearerAuthPrefix){
			key = key[7:]
		}

		return fn(r.Context(), key)
        {{- else if eq $value.Value.Scheme "basic" }}
		key := r.Header.Get("Authorization")
		if len(key) == 0 {
			return nil, httputil.ErrBasicAuthenticate
		}

		payload, err := base64.StdEncoding.DecodeString(key[len(basicAuthPrefix):]))
		if err != nil {
			return nil, httputil.ErrBasicAuthenticate
		}

		pair := strings.SplitN(payload, []byte(":"), 2)
		if len(pair) != 2 {
			return nil, httputil.ErrUnauthorized
		}

		return fn(r.Context(), pair[0],pair[1])
        {{- end }}
    {{- else  }}
        // TODO: Support: {{ toJson $value }}
		return nil, httputil.ErrUnauthorized
    {{- end }}
	}
}
{{- end }}

{{- if $.HasComplexAuth }}

// Complex Auth Support
{{- if .HasAuthorization -}}
// Scope is the individual security attribute to check for authorization
type Scope = string

// Scopes is the collection
type Scopes = []string

type AuthCheck struct {
    fn HttpAuthFunc
    Scopes
}
{{ else }}
type AuthCheck struct {
    fn HttpAuthFunc
}

{{ end }}
type SecurityGroup map[string]AuthCheck

type SecurityGroups  []SecurityGroup

type AuthResults map[string] *{{ $.CheckPackage $.Params.Auth $packageName }}

func (s SecurityGroup) Add(name string, fn HttpAuthFunc
{{- if .HasAuthorization -}}
, scopes ...string
{{- end -}}
) SecurityGroup{
	s[name] = AuthCheck{ fn: fn
{{- if .HasAuthorization -}}
, Scopes: scopes
{{- end -}}
}

	return s
}

func NewSecurityGroups(groups ...SecurityGroup) SecurityGroups{
	return groups
}

func doAuthorize(r *http.Request,
{{- if .HasAuthorization -}}
    authorize Authorizer,
{{- end -}}
    groups ...SecurityGroup) (*{{ $.CheckPackage $.Params.Auth $packageName }}, error){

	var user *{{ $.CheckPackage $.Params.Auth $packageName }}
	var err error

	users := AuthResults{}

    authorizeGroup := func (group SecurityGroup)(*{{ $.CheckPackage $.Params.Auth $packageName }}, error){
		for name, check := range group {
			user,ok := users[name]
			if !ok {
				user, err = check.fn(r)
				if err != nil {
					return nil, err
				}

				users[name] = user
			}
{{- if .HasAuthorization }}

			if len(check.Scopes) > 0 {
				err = authorize(user, check.Scopes...)
				if err != nil {
					return nil, err
				}
			}
{{ end -}}
		}

		return user, nil
	}

	for _, group := range groups {
		user, err := authorizeGroup(group)
		if err == nil {
			return user, nil
		}
	}

	return nil, err
}

{{- end }}
